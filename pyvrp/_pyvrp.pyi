from typing import Callable, Iterator, overload

import numpy as np

class CostEvaluator:
    def __init__(
        self,
        load_penalty: float,
        tw_penalty: float,
        dist_penalty: float,
    ) -> None: ...
    def load_penalty(self, load: float, capacity: float) -> float: ...
    def tw_penalty(self, time_warp: float) -> float: ...
    def dist_penalty(self, distance: float, max_distance: float) -> float: ...
    def penalised_cost(self, solution: Solution) -> float: ...
    def cost(self, solution: Solution) -> float: ...

class DynamicBitset:
    def __init__(self, num_bits: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> bool: ...
    def __setitem__(self, idx: int, value: bool) -> None: ...
    def all(self) -> bool: ...
    def any(self) -> bool: ...
    def none(self) -> bool: ...
    def count(self) -> int: ...
    def __len__(self) -> int: ...
    def __or__(self, other: DynamicBitset) -> DynamicBitset: ...
    def __and__(self, other: DynamicBitset) -> DynamicBitset: ...
    def __xor__(self, other: DynamicBitset) -> DynamicBitset: ...
    def __invert__(self) -> DynamicBitset: ...
    def reset(self) -> DynamicBitset: ...

class Client:
    x: float
    y: float
    delivery: list[float]
    pickup: list[float]
    service_duration: float
    tw_early: float
    tw_late: float
    release_time: float
    prize: float
    required: bool
    group: int | None
    name: str
    def __init__(
        self,
        x: float,
        y: float,
        delivery: list[float] = [],
        pickup: list[float] = [],
        service_duration: float = 0,
        tw_early: float = 0,
        tw_late: float = ...,
        release_time: float = 0,
        prize: float = 0,
        required: bool = True,
        group: int | None = None,
        *,
        name: str = "",
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class ClientGroup:
    required: bool
    mutually_exclusive: bool
    def __init__(
        self,
        clients: list[int] = [],
        required: bool = True,
    ) -> None: ...
    @property
    def clients(self) -> list[int]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def add_client(self, client: int) -> None: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class Depot:
    x: float
    y: float
    name: str
    def __init__(
        self,
        x: float,
        y: float,
        *,
        name: str = "",
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class VehicleType:
    num_available: int
    start_depot: int
    end_depot: int
    capacity: list[float]
    tw_early: float
    tw_late: float
    max_duration: float
    max_distance: float
    fixed_cost: float
    unit_distance_cost: float
    unit_duration_cost: float
    profile: int
    start_late: float
    name: str
    def __init__(
        self,
        num_available: int = 1,
        capacity: list[float] = [],
        start_depot: int = 0,
        end_depot: int = 0,
        fixed_cost: float = 0,
        tw_early: float = 0,
        tw_late: float = ...,
        max_duration: float = ...,
        max_distance: float = ...,
        unit_distance_cost: float = 1,
        unit_duration_cost: float = 0,
        profile: int = 0,
        start_late: float | None = None,
        *,
        name: str = "",
    ) -> None: ...
    def replace(
        self,
        num_available: int | None = None,
        capacity: list[float] | None = None,
        start_depot: int | None = None,
        end_depot: int | None = None,
        fixed_cost: float | None = None,
        tw_early: float | None = None,
        tw_late: float | None = None,
        max_duration: float | None = None,
        max_distance: float | None = None,
        unit_distance_cost: float | None = None,
        unit_duration_cost: float | None = None,
        profile: int | None = None,
        start_late: float | None = None,
        *,
        name: str | None = None,
    ) -> VehicleType: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class ProblemData:
    def __init__(
        self,
        clients: list[Client],
        depots: list[Depot],
        vehicle_types: list[VehicleType],
        distance_matrices: list[np.ndarray[float]],
        duration_matrices: list[np.ndarray[float]],
        groups: list[ClientGroup] = [],
    ) -> None: ...
    def location(self, idx: int) -> Client | Depot: ...
    def clients(self) -> list[Client]: ...
    def depots(self) -> list[Depot]: ...
    def groups(self) -> list[ClientGroup]: ...
    def vehicle_types(self) -> list[VehicleType]: ...
    def distance_matrices(self) -> list[np.ndarray[float]]: ...
    def duration_matrices(self) -> list[np.ndarray[float]]: ...
    def replace(
        self,
        clients: list[Client] | None = None,
        depots: list[Depot] | None = None,
        vehicle_types: list[VehicleType] | None = None,
        distance_matrices: list[np.ndarray[float]] | None = None,
        duration_matrices: list[np.ndarray[float]] | None = None,
        groups: list[ClientGroup] | None = None,
    ) -> ProblemData: ...
    def centroid(self) -> tuple[float, float]: ...
    def group(self, group: int) -> ClientGroup: ...
    def vehicle_type(self, vehicle_type: int) -> VehicleType: ...
    def distance_matrix(self, profile: int) -> np.ndarray[float]: ...
    def duration_matrix(self, profile: int) -> np.ndarray[float]: ...
    @property
    def num_clients(self) -> int: ...
    @property
    def num_groups(self) -> int: ...
    @property
    def num_depots(self) -> int: ...
    @property
    def num_locations(self) -> int: ...
    @property
    def num_vehicles(self) -> int: ...
    @property
    def num_vehicle_types(self) -> int: ...
    @property
    def num_profiles(self) -> int: ...
    @property
    def num_load_dimensions(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class Route:
    def __init__(
        self, data: ProblemData, visits: list[int], vehicle_type: int
    ) -> None: ...
    def __getitem__(self, idx: int) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def is_feasible(self) -> bool: ...
    def has_excess_load(self) -> bool: ...
    def has_excess_distance(self) -> bool: ...
    def has_time_warp(self) -> bool: ...
    def delivery(self) -> list[float]: ...
    def pickup(self) -> list[float]: ...
    def excess_load(self) -> list[float]: ...
    def excess_distance(self) -> float: ...
    def distance(self) -> float: ...
    def distance_cost(self) -> float: ...
    def duration(self) -> float: ...
    def duration_cost(self) -> float: ...
    def visits(self) -> list[int]: ...
    def time_warp(self) -> float: ...
    def start_time(self) -> float: ...
    def end_time(self) -> float: ...
    def slack(self) -> float: ...
    def service_duration(self) -> float: ...
    def travel_duration(self) -> float: ...
    def wait_duration(self) -> float: ...
    def release_time(self) -> float: ...
    def prizes(self) -> float: ...
    def centroid(self) -> tuple[float, float]: ...
    def vehicle_type(self) -> int: ...
    def start_depot(self) -> int: ...
    def end_depot(self) -> int: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class Solution:
    def __init__(
        self,
        data: ProblemData,
        routes: list[Route] | list[list[int]],
    ) -> None: ...
    @classmethod
    def make_random(
        cls, data: ProblemData, rng: RandomNumberGenerator
    ) -> Solution: ...
    def neighbours(self) -> list[tuple[int, int] | None]: ...
    def routes(self) -> list[Route]: ...
    def has_excess_load(self) -> bool: ...
    def has_excess_distance(self) -> bool: ...
    def has_time_warp(self) -> bool: ...
    def distance(self) -> float: ...
    def distance_cost(self) -> float: ...
    def duration(self) -> float: ...
    def duration_cost(self) -> float: ...
    def excess_load(self) -> list[float]: ...
    def excess_distance(self) -> float: ...
    def fixed_vehicle_cost(self) -> float: ...
    def time_warp(self) -> float: ...
    def prizes(self) -> float: ...
    def uncollected_prizes(self) -> float: ...
    def is_feasible(self) -> bool: ...
    def is_group_feasible(self) -> bool: ...
    def is_complete(self) -> bool: ...
    def num_routes(self) -> int: ...
    def num_clients(self) -> int: ...
    def num_missing_clients(self) -> int: ...
    def __copy__(self) -> Solution: ...
    def __deepcopy__(self, memo: dict) -> Solution: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple, /) -> None: ...

class PopulationParams:
    generation_size: int
    lb_diversity: float
    min_pop_size: int
    nb_close: int
    nb_elite: int
    ub_diversity: float
    def __init__(
        self,
        min_pop_size: int = 25,
        generation_size: int = 40,
        nb_elite: int = 4,
        nb_close: int = 5,
        lb_diversity: float = 0.1,
        ub_diversity: float = 0.5,
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def max_pop_size(self) -> int: ...

class SubPopulation:
    def __init__(
        self,
        diversity_op: Callable[[Solution, Solution], float],
        params: PopulationParams,
    ) -> None: ...
    def add(
        self, solution: Solution, cost_evaluator: CostEvaluator
    ) -> None: ...
    def purge(self, cost_evaluator: CostEvaluator) -> None: ...
    def update_fitness(self, cost_evaluator: CostEvaluator) -> None: ...
    def __getitem__(self, idx: int) -> SubPopulationItem: ...
    def __iter__(self) -> Iterator[SubPopulationItem]: ...
    def __len__(self) -> int: ...

class SubPopulationItem:
    @property
    def fitness(self) -> float: ...
    @property
    def solution(self) -> Solution: ...
    def avg_distance_closest(self) -> float: ...

class DistanceSegment:
    def __init__(self, distance: float) -> None: ...
    @staticmethod
    def merge(
        edge_distance: float,
        first: DistanceSegment,
        second: DistanceSegment,
    ) -> DistanceSegment: ...
    def distance(self) -> float: ...

class LoadSegment:
    def __init__(
        self, delivery: float, pickup: float, load: float
    ) -> None: ...
    @staticmethod
    def merge(first: LoadSegment, second: LoadSegment) -> LoadSegment: ...
    def delivery(self) -> float: ...
    def pickup(self) -> float: ...
    def load(self) -> float: ...

class DurationSegment:
    def __init__(
        self,
        duration: float,
        time_warp: float,
        tw_early: float,
        tw_late: float,
        release_time: float,
    ) -> None: ...
    @staticmethod
    def merge(
        edge_duration: float,
        first: DurationSegment,
        second: DurationSegment,
    ) -> DurationSegment: ...
    def duration(self) -> float: ...
    def tw_early(self) -> float: ...
    def tw_late(self) -> float: ...
    def time_warp(self, max_duration: float = ...) -> float: ...

class RandomNumberGenerator:
    @overload
    def __init__(self, seed: int) -> None: ...
    @overload
    def __init__(self, state: list[int]) -> None: ...
    @staticmethod
    def max() -> int: ...
    @staticmethod
    def min() -> int: ...
    def rand(self) -> float: ...
    def randint(self, high: int) -> int: ...
    def __call__(self) -> int: ...
    def state(self) -> list[int]: ...
